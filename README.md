# Bun Enterprise API Starter (Express + TypeScript + TSOA)

An enterprise-ready REST API boilerplate using Bun runtime with Express, TypeScript, TSOA routing, Swagger docs, and a clean service/repository architecture. Includes structured folders, logging (Pino), security middleware, and sample CRUD endpoints.

## Features

- Bun runtime with first-class TypeScript support
- Express with security middleware (helmet, cors, compression)
- TSOA decorators for controllers and route generation
- Swagger UI at `/docs` and spec at `/swagger.json` (generated to `src/generated/swagger.json`)
- Simple security via TSOA `@Security('anonymous')` with pluggable auth hook
- Pino logger with pretty output in dev
- Centralized error handling and 404 handler
- Clean architecture: controllers, services, repositories, models, middleware, config

## Project Structure

```
src/
	app.ts                 # Express app factory (middlewares, routes, Swagger UI)
	server.ts              # Boots the server
	authentication.ts      # TSOA auth hook (handles @Security)
	config/env.ts          # Env config via dotenv
	controllers/           # TSOA controllers (decorators + responses)
		UsersController.ts
	services/              # Business logic (async service layer)
		UserService.ts
	repositories/          # Data access (in-memory demo; swap for DB)
		UserRepository.ts
	models/                # Domain models & DTOs
		User.ts
	middleware/            # Logging, errors, 404
		errorHandler.ts
		notFound.ts
		requestLogger.ts
	generated/             # GENERATED by TSOA (do not edit)
		routes.ts            # Express routes
		swagger.json         # OpenAPI spec
tsoa.json                # TSOA config (spec + routes)
index.ts                 # Entry point (starts server)
```

## Setup

Install dependencies:

```powershell
bun install
```

Generate Swagger spec and routes (from TSOA controllers):

```powershell
bun run gen
```

Start in dev (watches files):

```powershell
bun run dev
```

Start normally:

```powershell
bun run start
```

Environment variables: create a `.env` based on `.env.example`.

## Sample Endpoints

- Health check: `GET /healthz`
- Users API (basePath `/api`):
  - `GET /api/users` – list users
  - `GET /api/users/{id}` – get user by id
  - `POST /api/users` – create user (JSON body: `{ name, email }`)
  - `PUT /api/users/{id}` – update user (JSON body: `{ name?, email? }`)
  - `DELETE /api/users/{id}` – delete user

Swagger UI: open `http://localhost:3000/docs`

## Notes

- Generated files:
  - `src/generated/routes.ts` – Express routes generated by TSOA
  - `src/generated/swagger.json` – OpenAPI spec generated by TSOA
- If you change controllers or models, re-run `bun run gen`.
- For production, Bun can run TypeScript directly; a separate build step is optional.

## Docker

Build the image:

```powershell
docker build -t bun-enterprise-api-starter .
```

Run the container:

```powershell
docker run -p 3000:3000 --env PORT=3000 bun-enterprise-api-starter
```

Then open:

- API: `http://localhost:3000/api/users`
- Swagger UI: `http://localhost:3000/docs`
- Health: `http://localhost:3000/healthz`

The Dockerfile uses `oven/bun:1.3.2-alpine`, installs deps with `bun install --frozen-lockfile`, and generates TSOA routes/spec during build into `src/generated`.

## Sample Code

Controller (`src/controllers/UsersController.ts`):

```ts
import {
  Body,
  Controller,
  Delete,
  Get,
  Path,
  Post,
  Put,
  Route,
  SuccessResponse,
  Tags,
  Security,
} from 'tsoa';
import type {
  CreateUserRequest,
  UpdateUserRequest,
  User,
} from '../models/User';
import { userService } from '../services/UserService';

@Route('users')
@Tags('Users')
@Security('anonymous')
export class UsersController extends Controller {
  public userService = userService;

  @SuccessResponse('200')
  @Get('')
  public async listUsers(): Promise<any> {
    try {
      const data = await this.userService.findAll();
      return { success: true, message: '', data };
    } catch (error) {
      this.setStatus(500);
      return { success: false, message: 'Internal Server Error', data: error };
    }
  }

  @SuccessResponse('201')
  @Post('')
  public async createUser(@Body() body: CreateUserRequest): Promise<any> {
    try {
      const data = await this.userService.create(body);
      this.setStatus(201);
      return { success: true, message: '', data };
    } catch (error) {
      this.setStatus(500);
      return { success: false, message: 'Internal Server Error', data: error };
    }
  }

  @SuccessResponse('200')
  @Get('{id}')
  public async getUser(@Path() id: string): Promise<any> {
    const data = await this.userService.findById(id);
    if (!data) {
      this.setStatus(404);
      return { success: false, message: 'User not found' };
    }
    return { success: true, message: '', data };
  }

  @SuccessResponse('200')
  @Put('{id}')
  public async updateUser(
    @Path() id: string,
    @Body() body: UpdateUserRequest,
  ): Promise<any> {
    const data = await this.userService.update(id, body);
    if (!data) {
      this.setStatus(404);
      return { success: false, message: 'User not found' };
    }
    return { success: true, message: '', data };
  }

  @SuccessResponse('200')
  @Delete('{id}')
  public async deleteUser(@Path() id: string): Promise<any> {
    const ok = await this.userService.delete(id);
    if (!ok) {
      this.setStatus(404);
      return { success: false, message: 'User not found' };
    }
    return { success: true, message: '', data: ok };
  }
}
```

Service (`src/services/UserService.ts`):

```ts
import { randomUUID } from 'node:crypto';
import type {
  CreateUserRequest,
  UpdateUserRequest,
  User,
} from '../models/User';
import { UserRepository } from '../repositories/UserRepository';

export class UserService {
  private userRepository: UserRepository;

  constructor() {
    this.userRepository = new UserRepository();
  }

  public async create(data: CreateUserRequest): Promise<User> {
    try {
      if (!data?.name || !data?.email) {
        throw new Error('Name and email are required');
      }

      const now = new Date();
      const user: User = {
        id: randomUUID(),
        name: data.name,
        email: data.email,
        createdAt: now,
        updatedAt: now,
      };

      const response = await this.userRepository.create(user);
      return response;
    } catch (error) {
      throw error;
    }
  }

  public async findAll(): Promise<User[]> {
    try {
      return await this.userRepository.findAll();
    } catch (error) {
      throw error;
    }
  }

  public async findById(id: string): Promise<User | undefined> {
    try {
      return await this.userRepository.findById(id);
    } catch (error) {
      throw error;
    }
  }

  public async update(
    id: string,
    updateData: UpdateUserRequest,
  ): Promise<User | undefined> {
    try {
      if (
        updateData &&
        (updateData.name === undefined || updateData.email === undefined)
      ) {
        throw new Error('Name and email are required');
      }
      const existing = await this.userRepository.findById(id);
      if (!existing) return undefined;
      return await this.userRepository.update(id, {
        ...updateData,
        updatedAt: new Date(),
      });
    } catch (error) {
      throw error;
    }
  }

  public async delete(id: string): Promise<boolean> {
    try {
      return await this.userRepository.delete(id);
    } catch (error) {
      throw error;
    }
  }
}

export const userService = new UserService();
```

Repository (`src/repositories/UserRepository.ts`):

```ts
import type { User } from '../models/User';

// Simple in-memory repository for demonstration. Replace with DB integration later.
export class UserRepository {
  private users = new Map<string, User>();

  async create(user: User): Promise<User> {
    this.users.set(user.id, user);
    return user;
  }

  async findAll(): Promise<User[]> {
    return Array.from(this.users.values());
  }

  async findById(id: string): Promise<User | undefined> {
    return this.users.get(id);
  }

  async update(
    id: string,
    updateData: Partial<User>,
  ): Promise<User | undefined> {
    const existing = this.users.get(id);
    if (!existing) return undefined;
    const updated: User = { ...existing, ...updateData };
    this.users.set(id, updated);
    return updated;
  }

  async delete(id: string): Promise<boolean> {
    return this.users.delete(id);
  }
}
```
